# ALFS — Anushiravan-Level Fair Scheduler (User-space)

ALFS یک شبیه‌ساز **scheduler در فضای کاربر (user-space)** است که از ایده‌های
Linux **Completely Fair Scheduler (CFS)** الهام گرفته شده است.
این پروژه قرار نیست جای CFS کرنل را بگیرد؛
هدف آن پیاده‌سازی مفاهیم اصلی زمان‌بندی منصفانه
به شکلی ساده‌تر، شفاف‌تر و **deterministic** است.

---

## Motivation

CFS تلاش می‌کند CPU را به‌صورت منصفانه و متناسب با وزن taskها تقسیم کند.
معیار اصلی این انصاف مفهومی به نام **vruntime** است که نشان می‌دهد
هر task چه‌قدر از CPU سهم گرفته است.

ALFS با حفظ همین ایده‌ی اصلی،
سعی می‌کند منطق CFS را بدون پیچیدگی‌های کرنل
و در قالب یک مدل قابل تست و قابل توضیح پیاده‌سازی کند.

---

## Key Ideas

- هر task متناسب با وزنش CPU دریافت می‌کند
- taskی که CPU کمتری گرفته باشد، `vruntime` کمتری دارد
- انتخاب بعدی معمولاً task با کمترین `vruntime` است
- رفتار scheduler باید **قابل پیش‌بینی و تکرارپذیر** باشد

---

## Design Overview

### User-space Scheduler

ALFS کاملاً در user-space اجرا می‌شود و کرنل لینوکس را تغییر نمی‌دهد.
این طراحی باعث می‌شود:
- پیاده‌سازی ساده‌تر باشد
- رفتار سیستم راحت‌تر تحلیل شود
- تست و دیباگ آسان‌تر انجام شود

### Heap-based Scheduling

در CFS واقعی از **Red-Black Tree** استفاده می‌شود.
در ALFS این ساختار با **Min-Heap** جایگزین شده است.

دلیل این انتخاب:
- انتخاب بعدی تقریباً همیشه کمترین `vruntime` است
- Min-Heap برای این الگو ساده و کافی است
- تحلیل و توضیح الگوریتم شفاف‌تر می‌شود

### Two-level Scheduling (cgroups)

ALFS از **cgroup scheduling** پشتیبانی می‌کند.
زمان‌بندی در دو سطح انجام می‌شود:

1. انتخاب cgroup با کمترین `vruntime`
2. انتخاب task با کمترین `vruntime` در داخل آن cgroup

برای این کار:
- یک heap برای cgroupها
- و یک heap برای taskهای داخل هر cgroup

استفاده می‌شود.

---

## Scheduling Algorithm

به‌روزرسانی `vruntime` بر اساس فرمول CFS انجام می‌شود:


vruntime += delta_exec * NICE_0_WEIGHT / weight
delta_exec = quanta_us



نتیجه:
- taskهایی که کمتر اجرا شده‌اند، زودتر دوباره انتخاب می‌شوند
- CPU به‌صورت نسبی و منصفانه تقسیم می‌شود

---

## Multi-CPU Support

ALFS از چند CPU پشتیبانی می‌کند.
در هر tick:
- CPUها به ترتیب ثابت بررسی می‌شوند
- برای هر CPU یک task انتخاب می‌شود

انتخاب task فقط در صورتی انجام می‌شود که:
- runnable باشد
- throttled نباشد
- محدودیت CPU affinity را نقض نکند
- در همان tick روی CPU دیگری انتخاب نشده باشد

---

## Determinism

رفتار scheduler کاملاً deterministic است:
- ترتیب CPUها ثابت است
- tie-break بین taskها با `(vruntime, seq, id)` انجام می‌شود
- خروجی برای یک ورودی مشخص همیشه یکسان است

این ویژگی برای تست و تحلیل بسیار مهم است.

---

## CPU Burst Support

ALFS از **CPU burst** پشتیبانی می‌کند.
در این حالت یک task می‌تواند برای مدت محدودی
بدون افزایش `vruntime` اجرا شود.

رفتار burst قابل تنظیم است:
- freeze
- freeze + pushback
- track (رفتار عادی)

این قابلیت برای شبیه‌سازی سیاست‌های مختلف زمان‌بندی اضافه شده است.

---

## I/O Model

ارتباط با scheduler از طریق **Unix Domain Socket (UDS)** انجام می‌شود.

- برنامه نقش client را دارد
- ورودی‌ها به‌صورت JSON و به شکل stream دریافت می‌شوند
- delimiter فرض نمی‌شود
- با شمارش brace و bracket یک JSON کامل استخراج می‌شود
- برای هر ورودی (TimeFrame)، یک خروجی JSON تولید می‌شود

---

## Metadata

برای تحلیل رفتار scheduler، متادیتا تولید می‌شود:
- **preemptions**: تعداد دفعات قطع شدن اجرای task
- **migrations**: تعداد جابجایی task بین CPUها

این داده‌ها کمک می‌کنند بفهمیم scheduler *چرا* یک تصمیم گرفته است،
نه فقط *چه* تصمیمی گرفته است.

---

## Testing

یک ابزار تست ساده وجود دارد که:
- traceها را خط‌به‌خط ارسال می‌کند
- خروجی scheduler را دریافت می‌کند
- امکان تست سناریوهای تک‌CPU و چند‌CPU را فراهم می‌کند

این ابزار برای بررسی صحت و تحلیل رفتار الگوریتم استفاده می‌شود.

---

## Summary

ALFS تلاش می‌کند ایده‌های اصلی CFS را:
- بدون وابستگی به کرنل
- با ساختاری ساده‌تر (Heap به‌جای RB-Tree)
- و با رفتاری کاملاً deterministic

پیاده‌سازی کند.

این پروژه بیشتر برای **یادگیری، تحلیل، تست و دفاع مفهومی**
طراحی شده است، نه استفاده‌ی عملی به‌عنوان scheduler سیستم‌عامل.





